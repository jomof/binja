// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BINJA_BINJA_H_
#define FLATBUFFERS_GENERATED_BINJA_BINJA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace binja {

struct CompiledBuildNinja;
struct CompiledBuildNinjaBuilder;

struct ParseNode;
struct ParseNodeBuilder;

struct ParseStringPiece;
struct ParseStringPieceBuilder;

struct ParseEvalString;
struct ParseEvalStringBuilder;

struct ParseBinding;
struct ParseBindingBuilder;

struct ParseRule;
struct ParseRuleBuilder;

struct ParseBuild;
struct ParseBuildBuilder;

struct ParsePool;
struct ParsePoolBuilder;

struct ParseDefault;
struct ParseDefaultBuilder;

struct ParseInclude;
struct ParseIncludeBuilder;

namespace ParseNode_ {

enum Type : int32_t {
  Type_RULE = 0,
  Type_BUILD = 1,
  Type_DEFAULT = 2,
  Type_POOL = 3,
  Type_BINDING = 4,
  Type_INCLUDE = 5,
  Type_MIN = Type_RULE,
  Type_MAX = Type_INCLUDE
};

inline const Type (&EnumValuesType())[6] {
  static const Type values[] = {
    Type_RULE,
    Type_BUILD,
    Type_DEFAULT,
    Type_POOL,
    Type_BINDING,
    Type_INCLUDE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[7] = {
    "RULE",
    "BUILD",
    "DEFAULT",
    "POOL",
    "BINDING",
    "INCLUDE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type_RULE, Type_INCLUDE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace ParseNode_

namespace ParseStringPiece_ {

enum Type : int32_t {
  Type_RAW = 0,
  Type_SPECIAL = 1,
  Type_MIN = Type_RAW,
  Type_MAX = Type_SPECIAL
};

inline const Type (&EnumValuesType())[2] {
  static const Type values[] = {
    Type_RAW,
    Type_SPECIAL
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[3] = {
    "RAW",
    "SPECIAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type_RAW, Type_SPECIAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace ParseStringPiece_

struct CompiledBuildNinja FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompiledBuildNinjaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARSE_NODE = 4,
    VT_RULE = 6,
    VT_BUILD = 8,
    VT_DEFAULT_ = 10,
    VT_POOL = 12,
    VT_BINDING = 14,
    VT_INCLUDE = 16
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseNode>> *parse_node() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseNode>> *>(VT_PARSE_NODE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseRule>> *rule() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseRule>> *>(VT_RULE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBuild>> *build() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBuild>> *>(VT_BUILD);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseDefault>> *default_() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseDefault>> *>(VT_DEFAULT_);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParsePool>> *pool() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParsePool>> *>(VT_POOL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *>(VT_BINDING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseInclude>> *include() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseInclude>> *>(VT_INCLUDE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARSE_NODE) &&
           verifier.VerifyVector(parse_node()) &&
           verifier.VerifyVectorOfTables(parse_node()) &&
           VerifyOffset(verifier, VT_RULE) &&
           verifier.VerifyVector(rule()) &&
           verifier.VerifyVectorOfTables(rule()) &&
           VerifyOffset(verifier, VT_BUILD) &&
           verifier.VerifyVector(build()) &&
           verifier.VerifyVectorOfTables(build()) &&
           VerifyOffset(verifier, VT_DEFAULT_) &&
           verifier.VerifyVector(default_()) &&
           verifier.VerifyVectorOfTables(default_()) &&
           VerifyOffset(verifier, VT_POOL) &&
           verifier.VerifyVector(pool()) &&
           verifier.VerifyVectorOfTables(pool()) &&
           VerifyOffset(verifier, VT_BINDING) &&
           verifier.VerifyVector(binding()) &&
           verifier.VerifyVectorOfTables(binding()) &&
           VerifyOffset(verifier, VT_INCLUDE) &&
           verifier.VerifyVector(include()) &&
           verifier.VerifyVectorOfTables(include()) &&
           verifier.EndTable();
  }
};

struct CompiledBuildNinjaBuilder {
  typedef CompiledBuildNinja Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parse_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseNode>>> parse_node) {
    fbb_.AddOffset(CompiledBuildNinja::VT_PARSE_NODE, parse_node);
  }
  void add_rule(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseRule>>> rule) {
    fbb_.AddOffset(CompiledBuildNinja::VT_RULE, rule);
  }
  void add_build(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBuild>>> build) {
    fbb_.AddOffset(CompiledBuildNinja::VT_BUILD, build);
  }
  void add_default_(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseDefault>>> default_) {
    fbb_.AddOffset(CompiledBuildNinja::VT_DEFAULT_, default_);
  }
  void add_pool(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParsePool>>> pool) {
    fbb_.AddOffset(CompiledBuildNinja::VT_POOL, pool);
  }
  void add_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> binding) {
    fbb_.AddOffset(CompiledBuildNinja::VT_BINDING, binding);
  }
  void add_include(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseInclude>>> include) {
    fbb_.AddOffset(CompiledBuildNinja::VT_INCLUDE, include);
  }
  explicit CompiledBuildNinjaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompiledBuildNinja> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompiledBuildNinja>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompiledBuildNinja> CreateCompiledBuildNinja(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseNode>>> parse_node = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseRule>>> rule = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBuild>>> build = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseDefault>>> default_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParsePool>>> pool = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> binding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseInclude>>> include = 0) {
  CompiledBuildNinjaBuilder builder_(_fbb);
  builder_.add_include(include);
  builder_.add_binding(binding);
  builder_.add_pool(pool);
  builder_.add_default_(default_);
  builder_.add_build(build);
  builder_.add_rule(rule);
  builder_.add_parse_node(parse_node);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompiledBuildNinja> CreateCompiledBuildNinjaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<binja::ParseNode>> *parse_node = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseRule>> *rule = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseBuild>> *build = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseDefault>> *default_ = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParsePool>> *pool = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseBinding>> *binding = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseInclude>> *include = nullptr) {
  auto parse_node__ = parse_node ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseNode>>(*parse_node) : 0;
  auto rule__ = rule ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseRule>>(*rule) : 0;
  auto build__ = build ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseBuild>>(*build) : 0;
  auto default___ = default_ ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseDefault>>(*default_) : 0;
  auto pool__ = pool ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParsePool>>(*pool) : 0;
  auto binding__ = binding ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseBinding>>(*binding) : 0;
  auto include__ = include ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseInclude>>(*include) : 0;
  return binja::CreateCompiledBuildNinja(
      _fbb,
      parse_node__,
      rule__,
      build__,
      default___,
      pool__,
      binding__,
      include__);
}

struct ParseNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TABLE_OFFSET = 6
  };
  binja::ParseNode_::Type type() const {
    return static_cast<binja::ParseNode_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  uint64_t table_offset() const {
    return GetField<uint64_t>(VT_TABLE_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint64_t>(verifier, VT_TABLE_OFFSET, 8) &&
           verifier.EndTable();
  }
};

struct ParseNodeBuilder {
  typedef ParseNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(binja::ParseNode_::Type type) {
    fbb_.AddElement<int32_t>(ParseNode::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_table_offset(uint64_t table_offset) {
    fbb_.AddElement<uint64_t>(ParseNode::VT_TABLE_OFFSET, table_offset, 0);
  }
  explicit ParseNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseNode> CreateParseNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    binja::ParseNode_::Type type = binja::ParseNode_::Type_RULE,
    uint64_t table_offset = 0) {
  ParseNodeBuilder builder_(_fbb);
  builder_.add_table_offset(table_offset);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ParseStringPiece FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseStringPieceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  binja::ParseStringPiece_::Type type() const {
    return static_cast<binja::ParseStringPiece_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ParseStringPieceBuilder {
  typedef ParseStringPiece Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(binja::ParseStringPiece_::Type type) {
    fbb_.AddElement<int32_t>(ParseStringPiece::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(ParseStringPiece::VT_VALUE, value);
  }
  explicit ParseStringPieceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseStringPiece> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseStringPiece>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseStringPiece> CreateParseStringPiece(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    binja::ParseStringPiece_::Type type = binja::ParseStringPiece_::Type_RAW,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  ParseStringPieceBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseStringPiece> CreateParseStringPieceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    binja::ParseStringPiece_::Type type = binja::ParseStringPiece_::Type_RAW,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return binja::CreateParseStringPiece(
      _fbb,
      type,
      value__);
}

struct ParseEvalString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseEvalStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIECE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseStringPiece>> *piece() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseStringPiece>> *>(VT_PIECE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PIECE) &&
           verifier.VerifyVector(piece()) &&
           verifier.VerifyVectorOfTables(piece()) &&
           verifier.EndTable();
  }
};

struct ParseEvalStringBuilder {
  typedef ParseEvalString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_piece(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseStringPiece>>> piece) {
    fbb_.AddOffset(ParseEvalString::VT_PIECE, piece);
  }
  explicit ParseEvalStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseEvalString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseEvalString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseEvalString> CreateParseEvalString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseStringPiece>>> piece = 0) {
  ParseEvalStringBuilder builder_(_fbb);
  builder_.add_piece(piece);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseEvalString> CreateParseEvalStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<binja::ParseStringPiece>> *piece = nullptr) {
  auto piece__ = piece ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseStringPiece>>(*piece) : 0;
  return binja::CreateParseEvalString(
      _fbb,
      piece__);
}

struct ParseBinding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseBindingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_FINAL_POSITION = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const binja::ParseEvalString *value() const {
    return GetPointer<const binja::ParseEvalString *>(VT_VALUE);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParseBindingBuilder {
  typedef ParseBinding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(ParseBinding::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<binja::ParseEvalString> value) {
    fbb_.AddOffset(ParseBinding::VT_VALUE, value);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParseBinding::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParseBindingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseBinding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseBinding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseBinding> CreateParseBinding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<binja::ParseEvalString> value = 0,
    uint64_t final_position = 0) {
  ParseBindingBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseBinding> CreateParseBindingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    ::flatbuffers::Offset<binja::ParseEvalString> value = 0,
    uint64_t final_position = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return binja::CreateParseBinding(
      _fbb,
      key__,
      value,
      final_position);
}

struct ParseRule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseRuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BINDING = 6,
    VT_RULE_POSITION = 8,
    VT_FINAL_POSITION = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *>(VT_BINDING);
  }
  uint64_t rule_position() const {
    return GetField<uint64_t>(VT_RULE_POSITION, 0);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_BINDING) &&
           verifier.VerifyVector(binding()) &&
           verifier.VerifyVectorOfTables(binding()) &&
           VerifyField<uint64_t>(verifier, VT_RULE_POSITION, 8) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParseRuleBuilder {
  typedef ParseRule Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ParseRule::VT_NAME, name);
  }
  void add_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> binding) {
    fbb_.AddOffset(ParseRule::VT_BINDING, binding);
  }
  void add_rule_position(uint64_t rule_position) {
    fbb_.AddElement<uint64_t>(ParseRule::VT_RULE_POSITION, rule_position, 0);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParseRule::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParseRuleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseRule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseRule>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseRule> CreateParseRule(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> binding = 0,
    uint64_t rule_position = 0,
    uint64_t final_position = 0) {
  ParseRuleBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_rule_position(rule_position);
  builder_.add_binding(binding);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseRule> CreateParseRuleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseBinding>> *binding = nullptr,
    uint64_t rule_position = 0,
    uint64_t final_position = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto binding__ = binding ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseBinding>>(*binding) : 0;
  return binja::CreateParseRule(
      _fbb,
      name__,
      binding__,
      rule_position,
      final_position);
}

struct ParseBuild FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseBuildBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OUT = 6,
    VT_IMPLICIT_OUT_COUNT = 8,
    VT_IN = 10,
    VT_IMPLICIT_IN_COUNT = 12,
    VT_ORDER_ONLY_IN_COUNT = 14,
    VT_VALIDATIONS = 16,
    VT_BINDINGS = 18,
    VT_RULE_POSITION = 20,
    VT_FINAL_POSITION = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *out() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *>(VT_OUT);
  }
  int32_t implicit_out_count() const {
    return GetField<int32_t>(VT_IMPLICIT_OUT_COUNT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *in() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *>(VT_IN);
  }
  int32_t implicit_in_count() const {
    return GetField<int32_t>(VT_IMPLICIT_IN_COUNT, 0);
  }
  int32_t order_only_in_count() const {
    return GetField<int32_t>(VT_ORDER_ONLY_IN_COUNT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *validations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *>(VT_VALIDATIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *bindings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>> *>(VT_BINDINGS);
  }
  uint64_t rule_position() const {
    return GetField<uint64_t>(VT_RULE_POSITION, 0);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OUT) &&
           verifier.VerifyVector(out()) &&
           verifier.VerifyVectorOfTables(out()) &&
           VerifyField<int32_t>(verifier, VT_IMPLICIT_OUT_COUNT, 4) &&
           VerifyOffset(verifier, VT_IN) &&
           verifier.VerifyVector(in()) &&
           verifier.VerifyVectorOfTables(in()) &&
           VerifyField<int32_t>(verifier, VT_IMPLICIT_IN_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_ORDER_ONLY_IN_COUNT, 4) &&
           VerifyOffset(verifier, VT_VALIDATIONS) &&
           verifier.VerifyVector(validations()) &&
           verifier.VerifyVectorOfTables(validations()) &&
           VerifyOffset(verifier, VT_BINDINGS) &&
           verifier.VerifyVector(bindings()) &&
           verifier.VerifyVectorOfTables(bindings()) &&
           VerifyField<uint64_t>(verifier, VT_RULE_POSITION, 8) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParseBuildBuilder {
  typedef ParseBuild Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ParseBuild::VT_NAME, name);
  }
  void add_out(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> out) {
    fbb_.AddOffset(ParseBuild::VT_OUT, out);
  }
  void add_implicit_out_count(int32_t implicit_out_count) {
    fbb_.AddElement<int32_t>(ParseBuild::VT_IMPLICIT_OUT_COUNT, implicit_out_count, 0);
  }
  void add_in(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> in) {
    fbb_.AddOffset(ParseBuild::VT_IN, in);
  }
  void add_implicit_in_count(int32_t implicit_in_count) {
    fbb_.AddElement<int32_t>(ParseBuild::VT_IMPLICIT_IN_COUNT, implicit_in_count, 0);
  }
  void add_order_only_in_count(int32_t order_only_in_count) {
    fbb_.AddElement<int32_t>(ParseBuild::VT_ORDER_ONLY_IN_COUNT, order_only_in_count, 0);
  }
  void add_validations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> validations) {
    fbb_.AddOffset(ParseBuild::VT_VALIDATIONS, validations);
  }
  void add_bindings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> bindings) {
    fbb_.AddOffset(ParseBuild::VT_BINDINGS, bindings);
  }
  void add_rule_position(uint64_t rule_position) {
    fbb_.AddElement<uint64_t>(ParseBuild::VT_RULE_POSITION, rule_position, 0);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParseBuild::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParseBuildBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseBuild> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseBuild>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseBuild> CreateParseBuild(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> out = 0,
    int32_t implicit_out_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> in = 0,
    int32_t implicit_in_count = 0,
    int32_t order_only_in_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> validations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseBinding>>> bindings = 0,
    uint64_t rule_position = 0,
    uint64_t final_position = 0) {
  ParseBuildBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_rule_position(rule_position);
  builder_.add_bindings(bindings);
  builder_.add_validations(validations);
  builder_.add_order_only_in_count(order_only_in_count);
  builder_.add_implicit_in_count(implicit_in_count);
  builder_.add_in(in);
  builder_.add_implicit_out_count(implicit_out_count);
  builder_.add_out(out);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseBuild> CreateParseBuildDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseEvalString>> *out = nullptr,
    int32_t implicit_out_count = 0,
    const std::vector<::flatbuffers::Offset<binja::ParseEvalString>> *in = nullptr,
    int32_t implicit_in_count = 0,
    int32_t order_only_in_count = 0,
    const std::vector<::flatbuffers::Offset<binja::ParseEvalString>> *validations = nullptr,
    const std::vector<::flatbuffers::Offset<binja::ParseBinding>> *bindings = nullptr,
    uint64_t rule_position = 0,
    uint64_t final_position = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto out__ = out ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseEvalString>>(*out) : 0;
  auto in__ = in ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseEvalString>>(*in) : 0;
  auto validations__ = validations ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseEvalString>>(*validations) : 0;
  auto bindings__ = bindings ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseBinding>>(*bindings) : 0;
  return binja::CreateParseBuild(
      _fbb,
      name__,
      out__,
      implicit_out_count,
      in__,
      implicit_in_count,
      order_only_in_count,
      validations__,
      bindings__,
      rule_position,
      final_position);
}

struct ParsePool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParsePoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DEPTH = 6,
    VT_POOL_POSITION = 8,
    VT_DEPTH_POSITION = 10,
    VT_FINAL_POSITION = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const binja::ParseEvalString *depth() const {
    return GetPointer<const binja::ParseEvalString *>(VT_DEPTH);
  }
  uint64_t pool_position() const {
    return GetField<uint64_t>(VT_POOL_POSITION, 0);
  }
  uint64_t depth_position() const {
    return GetField<uint64_t>(VT_DEPTH_POSITION, 0);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEPTH) &&
           verifier.VerifyTable(depth()) &&
           VerifyField<uint64_t>(verifier, VT_POOL_POSITION, 8) &&
           VerifyField<uint64_t>(verifier, VT_DEPTH_POSITION, 8) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParsePoolBuilder {
  typedef ParsePool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ParsePool::VT_NAME, name);
  }
  void add_depth(::flatbuffers::Offset<binja::ParseEvalString> depth) {
    fbb_.AddOffset(ParsePool::VT_DEPTH, depth);
  }
  void add_pool_position(uint64_t pool_position) {
    fbb_.AddElement<uint64_t>(ParsePool::VT_POOL_POSITION, pool_position, 0);
  }
  void add_depth_position(uint64_t depth_position) {
    fbb_.AddElement<uint64_t>(ParsePool::VT_DEPTH_POSITION, depth_position, 0);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParsePool::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParsePoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParsePool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParsePool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParsePool> CreateParsePool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<binja::ParseEvalString> depth = 0,
    uint64_t pool_position = 0,
    uint64_t depth_position = 0,
    uint64_t final_position = 0) {
  ParsePoolBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_depth_position(depth_position);
  builder_.add_pool_position(pool_position);
  builder_.add_depth(depth);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParsePool> CreateParsePoolDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<binja::ParseEvalString> depth = 0,
    uint64_t pool_position = 0,
    uint64_t depth_position = 0,
    uint64_t final_position = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return binja::CreateParsePool(
      _fbb,
      name__,
      depth,
      pool_position,
      depth_position,
      final_position);
}

struct ParseDefault FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseDefaultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFAULT_ = 4,
    VT_DEFAULT_POSITIONS = 6,
    VT_FINAL_POSITION = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *default_() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>> *>(VT_DEFAULT_);
  }
  const ::flatbuffers::Vector<uint64_t> *default_positions() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DEFAULT_POSITIONS);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEFAULT_) &&
           verifier.VerifyVector(default_()) &&
           verifier.VerifyVectorOfTables(default_()) &&
           VerifyOffset(verifier, VT_DEFAULT_POSITIONS) &&
           verifier.VerifyVector(default_positions()) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParseDefaultBuilder {
  typedef ParseDefault Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_default_(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> default_) {
    fbb_.AddOffset(ParseDefault::VT_DEFAULT_, default_);
  }
  void add_default_positions(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> default_positions) {
    fbb_.AddOffset(ParseDefault::VT_DEFAULT_POSITIONS, default_positions);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParseDefault::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParseDefaultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseDefault> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseDefault>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseDefault> CreateParseDefault(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<binja::ParseEvalString>>> default_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> default_positions = 0,
    uint64_t final_position = 0) {
  ParseDefaultBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_default_positions(default_positions);
  builder_.add_default_(default_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParseDefault> CreateParseDefaultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<binja::ParseEvalString>> *default_ = nullptr,
    const std::vector<uint64_t> *default_positions = nullptr,
    uint64_t final_position = 0) {
  auto default___ = default_ ? _fbb.CreateVector<::flatbuffers::Offset<binja::ParseEvalString>>(*default_) : 0;
  auto default_positions__ = default_positions ? _fbb.CreateVector<uint64_t>(*default_positions) : 0;
  return binja::CreateParseDefault(
      _fbb,
      default___,
      default_positions__,
      final_position);
}

struct ParseInclude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParseIncludeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SCOPE = 4,
    VT_PATH = 6,
    VT_FINAL_POSITION = 8
  };
  bool new_scope() const {
    return GetField<uint8_t>(VT_NEW_SCOPE, 0) != 0;
  }
  const binja::ParseEvalString *path() const {
    return GetPointer<const binja::ParseEvalString *>(VT_PATH);
  }
  uint64_t final_position() const {
    return GetField<uint64_t>(VT_FINAL_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NEW_SCOPE, 1) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyTable(path()) &&
           VerifyField<uint64_t>(verifier, VT_FINAL_POSITION, 8) &&
           verifier.EndTable();
  }
};

struct ParseIncludeBuilder {
  typedef ParseInclude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_scope(bool new_scope) {
    fbb_.AddElement<uint8_t>(ParseInclude::VT_NEW_SCOPE, static_cast<uint8_t>(new_scope), 0);
  }
  void add_path(::flatbuffers::Offset<binja::ParseEvalString> path) {
    fbb_.AddOffset(ParseInclude::VT_PATH, path);
  }
  void add_final_position(uint64_t final_position) {
    fbb_.AddElement<uint64_t>(ParseInclude::VT_FINAL_POSITION, final_position, 0);
  }
  explicit ParseIncludeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParseInclude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParseInclude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParseInclude> CreateParseInclude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool new_scope = false,
    ::flatbuffers::Offset<binja::ParseEvalString> path = 0,
    uint64_t final_position = 0) {
  ParseIncludeBuilder builder_(_fbb);
  builder_.add_final_position(final_position);
  builder_.add_path(path);
  builder_.add_new_scope(new_scope);
  return builder_.Finish();
}

}  // namespace binja

#endif  // FLATBUFFERS_GENERATED_BINJA_BINJA_H_
